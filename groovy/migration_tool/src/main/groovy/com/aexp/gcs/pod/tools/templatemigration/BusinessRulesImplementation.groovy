package com.aexp.gcs.pod.tools.templatemigration

import org.springframework.expression.ExpressionParser
import org.springframework.expression.spel.standard.SpelExpressionParser


/**
 * Implements calls Business Rules, Formatters or Transformation in a given business-rules-<feeder>/.../poa/transform/template/<TEMPLATEID>/<TEMPLATEID>.java file
 * by making the java class concrete, implementing execute method, adding the import statements and adding necessary SpEL expressions to be executed
 * based on a set of rules contained for a variable.
 *   
 * @author Victor Navarro
 *
 */
class BusinessRulesImplementation
{
	File aTemplateFile
	StringBuilder templateSrc
	String aSpelTemplate = "%null_safe_field_path% = T(%validator_classname%).execute(%null_safe_field_path%)"
	String aExecSpelTemplate = "spelParser.parseExpression(\"%spel_expression%\").getValue(%root_object%);"
	String TAB_SPACE = '    '
	String executeMethodTemplate = """

${TAB_SPACE}@Override
${TAB_SPACE}public void execute(EnvelopeType Envelope)
${TAB_SPACE}{
${TAB_SPACE}${TAB_SPACE}/* ******************************************************************************************
${TAB_SPACE}${TAB_SPACE}   WARNING: The contents of this execute() method are autogenerated, if you need to change
${TAB_SPACE}${TAB_SPACE}   any of the the SpEL expressions DO NOT remove the autogenerated ones, just comment the
${TAB_SPACE}${TAB_SPACE}   original autogenerated line and add your custom code
${TAB_SPACE}${TAB_SPACE}****************************************************************************************** */
${TAB_SPACE}
${TAB_SPACE}${TAB_SPACE}ExpressionParser spelParser = new SpelExpressionParser();
${TAB_SPACE}
${TAB_SPACE}}
"""

	/**
	 * Constructor of this class takes the File object that references to the business-rules-<feeder>/.../poa/transform/template/<TEMPLATEID>/<TEMPLATEID>.java file
	 * and loads the text into a StringBuilder for further manipulation
	 * @param pTemplateTransformationFile the TEMPLATEID.java class that extends AbstractTransformation
	 */
	public BusinessRulesImplementation(File pTemplateTransformationFile)
	{
		if (!pTemplateTransformationFile.exists())
			throw new Exception("Transformation file ${pTemplateTransformationFile.absolutePath} not found")

		this.aTemplateFile	=	pTemplateTransformationFile
		this.templateSrc	=	new StringBuilder(this.aTemplateFile.text)
	}
	
	
	/**
	 * Writes all changes made to the source code back to the java file
	 */
	public void persist()
	{
		this.aTemplateFile.withWriter { it << this.templateSrc.toString() }
	}
	
	
	/**
	 * Add required "import" statements to the header of the java file if they are not already present
	 */
	protected void addImports()
	{
		def aMatcher	=	this.templateSrc.toString() =~ /(?m)^import\s+(.*)?;$/
		
		['org.springframework.expression.spel.standard.SpelExpressionParser',
		 'org.springframework.expression.ExpressionParser'].each{ pImport ->
		 
			boolean foundFlg = false
			aMatcher.each{ aMatch ->
				if (aMatch[1] == pImport) {
					foundFlg  = true
				}
			}
			if (!foundFlg) {
				this.templateSrc.insert(this.templateSrc.indexOf('import'), "import ${pImport};\n")
			}
		}
	}
	
	
	/**
	 * Checks if the class definition is the one of an abstract class. If so, takes the 
	 * "abstract" part out and provides a default execute() method
	 */
	protected void convertToConcreteClass()
	{
		String aPattern	=	'(?m)^(abstract\\s+class\\s+' + this.getTemplateId() + '.*)$'
		def aMatcher	=	this.templateSrc.toString()  =~ aPattern
		
		if (aMatcher.size()) {
			this.templateSrc	=	 new StringBuilder(this.templateSrc.replaceFirst(aPattern){ "class ${this.getTemplateId()}" })
		    int aPos = this.templateSrc.indexOf('{', this.templateSrc.indexOf("class ${this.getTemplateId()}"))
		    
		    this.templateSrc.insert(aPos + 1, executeMethodTemplate)
			this.addImports()
		}		
	}
	
	
	/**
	 * This method is handled a variable that contains a collection of "business-rules". Each one of these business rules will be 
	 * translated into a SpEL expression that get parsed in the execute() method
	 */
	public void addTransformations(pVariable)
	{
		this.convertToConcreteClass()
		
		String executeMethodSrc =	this.getExecuteMethodSource()
		
		pVariable."business-rules"?.each{ pBusinessRule ->
			String aSpel = this.generateSpel(pVariable.mapping, pBusinessRule.rule)
			
			if (executeMethodSrc.indexOf(aSpel) == -1) {
				this.addSpelCall(aSpel)
			}
		}
	}
	
	/**
	 * Adds a SpEL expression parsing code and execution at the end of the execute() method
	 */
	protected void addSpelCall(pSpel)
	{
		StringBuilder	aMethodSrcBldr	=	new StringBuilder(this.getExecuteMethodSource())
		
		if (aMethodSrcBldr.indexOf(pSpel) > 0) return
		
		String 			aParamName		=	this.getEnvelopeTypeParamName()
		String			aSpelExecSrc	=	this.aExecSpelTemplate
														.replaceAll('%spel_expression%', pSpel)
														.replaceAll('%root_object%', aParamName)
		int				aMethodPos		=	this.templateSrc.indexOf(aMethodSrcBldr.toString())
		int				aMethodLen		=	aMethodSrcBldr.toString().length()
		int 			aClosMethodPos	=	aMethodSrcBldr.lastIndexOf('}')
		
		aMethodSrcBldr.insert(aClosMethodPos, "${TAB_SPACE}${aSpelExecSrc}\n${TAB_SPACE}")
		
		this.templateSrc.replace(aMethodPos, aMethodPos + aMethodLen, aMethodSrcBldr.toString())
	}
	
	/**
	 * Generates the text corresponding to a SpEL expression based on the variable mapping and business rule, formatting or transformation to run
	 */
	protected String generateSpel(String pFieldMapping, String pValidatorClassName)
	{
		//	Add "uncapitalize" method to String class at run time if not already defined.
		if (!String.metaClass.methods*.name.any{ it == 'uncapitalize'}) {
			String.metaClass.uncapitalize = { delegate[0].toLowerCase() + delegate[1..-1] }
		}
		
		def aMapLst	=	pFieldMapping.split('\\.')
		String aNullSafeFieldPath	=	aMapLst.init().tail().collect{ it.uncapitalize() + '?.' }.join() + aMapLst.last().trim().uncapitalize()
		
		aSpelTemplate.replaceAll('%null_safe_field_path%', aNullSafeFieldPath).replaceAll('%validator_classname%', pValidatorClassName)
	}
	
	
	/**
	 * Retrieves the TEMPLATEID from the given TEMPLATEID.java file
	 */
	private String getTemplateId()
	{
		aTemplateFile.name.substring(0, aTemplateFile.name.indexOf('.'))
	}
	
	
	/**
	 * Returns the execute() method source code
	 */
	private String getExecuteMethodSource()
	{
		def blocksCount 			= 1
		def aMatcher				= this.templateSrc =~ /(?s)(\s+public\s+void\s+execute.*?\{)/
		if (!aMatcher.size()) return
		
		int aPos1 					= this.templateSrc.indexOf(aMatcher[0][1]) + aMatcher[0][1].size()
		StringBuilder methodBody	= new StringBuilder(aMatcher[0][1])
		
		for (int i = aPos1; i < this.templateSrc.size(); i++) {
			methodBody << this.templateSrc.charAt(i)
			if (this.templateSrc.charAt(i) == '{') blocksCount++
			if (this.templateSrc.charAt(i) == '}') blocksCount--
			if (blocksCount == 0) break;
		}
		
		methodBody.toString()
	}
	
	
	/**
	 * Determines what is the name of the EnvelopeType parameter of the execute method
	 */
	private String getEnvelopeTypeParamName()
	{
		def aPattern	=	/(?s)\s+public\s+void\s+execute\s*\(.*?EnvelopeType\s+(.+?)[\),\s].*?\{/
		def aMatcher	=	this.templateSrc =~ aPattern
		
		aMatcher.size() ? aMatcher[0][1] : null
	}
}
