package com.aexp.gcs.pod.tools.templatemigration

import groovy.io.FileType
import groovy.json.JsonSlurper

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Component

/**
 * This is the class that implements the steps necessary to carry out the Migration of the 
 * generated files and validation information over to the required modules, folder, xml and java files.<br/>
 * In summary this class performs the following tasks:<br/>
 * 		1. Creates "business-rules-&lt;feeder%gt;" if it does not already exists.<br/>
 * 		2. Copies generated java files under sourceFolder/&lt;FEEDER&gt;/POA/com to their corresponding places under business-rules-&lt;feeder&gt;<br/>
 * 		3. Copies over the generated template transaction XML file over to the template-transaction-info location.<br/>
 * 		4. Creates and/or edits XML validation files located under business-rules module depending on static variable validation information contained in the JSON block generated by the Translation Tool<br/>
 * 		5. Edits necessary Java code in business-rules-&lt;feeder&gt;/src/main/java/com/aexp/gcs/poa/validate/feeder/&lt;FEEDER&gt;.java depending on dynamic variable validation information contained in the JSON block generated by the Translation Tool<br/>
 * 
 * @author Victor Navarro
 *
 */

@Component
class TemplateMigrator
{
	@Autowired
	AppSettings appSettings
	
	@Autowired
	MessagePlaceHolder messagePlaceholder
	
	Map beanConstraintsHandlerMap = [:]
	Map dynamicValidationHandlerMap = [:]
	
	static String	NO_MAPPING_STR	=	'Probably Dynamic'
	
	/**
	 * Traverses over the Translation Tool output folder and performs module creation, file copying, file merge per each one of the generated files
	 */
	public void performMigration()
	{
		this.validateGeneratedFiles()
		
		File aSourceDir = new File(this.appSettings.sourceFolder)
		
		//	Adding custom method to String class
		String.metaClass.uncapitalize = {
			delegate[0].toLowerCase() + delegate[1..-1]
		}
		
		aSourceDir.eachDirMatch(~/[A-Z]{3}/){ File aFeederDir ->
			String aFeederName	=	aFeederDir.getName()
			
			println "Processing ${aFeederName}"
			
			//	Create corresponding module structure if doesn't exist
			this.createBusinessRuleModule(aFeederName)
			
			File aTemplatesDir = new File("${aFeederDir.absolutePath}/POA")
			
			aTemplatesDir.eachFileMatch(FileType.FILES, ~/.*?\.txt/) { File aPoaXml ->
				String aTemplateName = aPoaXml.getName().substring(0, aPoaXml.getName().lastIndexOf('.'))
				
				println "\t${aTemplateName}"
				this.addPOAFilesToBusinessRulesModule(aFeederName, aTemplateName)
				this.addPOAFileToTransactionInfoModule(aFeederName, aTemplateName)
				this.processTemplateVariables(aFeederName, aTemplateName)
			}
		}
		
		this.closeAllFileHandlers()
	}
	
	
	/**
	 * Copies the generated &lt;template&gt;.xml into the template-transaction-info module, whose root location is specified in the application.yml file
	 * by the templateTransactionInfo parameter.<br/>
	 * If the corresponding feeder folder does not exists this method creates it before copying the xml file into it.<br/>
	 * If the corresponding feeder folder already exists this method checks to see if the file already exists, <br/>
	 * only copies the xml file if it is not already present at the target folder <br/>
	 * @param pFeeder the feeder name
	 * @param pTemplate the template name
	 * @return returns true or false whether the target file was created or not
	 */
	private boolean addPOAFileToTransactionInfoModule(pFeeder, pTemplate)
	{
		File	aTemplateDir	= new File("${appSettings.templateTransactionInfo}/src/main/resources/transactionInfo/${pFeeder.toUpperCase()}")
		File 	aTemplateFile	= new File("${appSettings.templateTransactionInfo}/src/main/resources/transactionInfo/${pFeeder.toUpperCase()}/${pTemplate}.xml")
		File	aPoaFile		= new File("${appSettings.sourceFolder}/${pFeeder}/POA/${pTemplate}.xml")
		boolean	aResult			= false
		
		//	Create feeder folder if does not exists
		if (!aTemplateDir.exists()) {
			aTemplateDir.mkdirs()
		}
		
		//	Only copy if the file is not there already
		if (!aTemplateFile.exists()) {
			aTemplateFile.withWriter { it << aPoaFile.text }
			aResult = true
		}
		
		aResult
	}
	
	/**
	 * Copies generated fields from the POAs subfolders to the appropriate locations at the business-rules-&lt;feeder&gt; projects. Only makes a 
	 * copy operation if the target location does not have the corresponding file in place.<br/>
	 * 
	 * Only needs to create the appropriate template package under transform.template.<br/>
	 * 
	 * Also makes a merge of the file located at validate.feeder.&lt;feeder&gt;.java from the corresponding .java file from POA. Only needs to add the
	 * getters and setters that are not already present. 
	 * @param pFeeder the feeder name
	 * @param pTemplate the template name
	 */
	private void addPOAFilesToBusinessRulesModule(pFeeder, pTemplate)
	{
		pFeeder = pFeeder.toUpperCase()
		pTemplate = pTemplate.toUpperCase()
		String aModuleName = "/business-rules-${pFeeder.toLowerCase()}"
		File aModuleFolder = new File("${appSettings.outputFolder}/${aModuleName}")
		File aPoaFolder = new File("${appSettings.sourceFolder}/${pFeeder}/POA")
		
		String aTemplateLocation = "${appSettings.outputFolder}/${aModuleName}/src/main/java/com/aexp/gcs/poa/transform/template/${pTemplate}"
		File aTemplateFolder = new File(aTemplateLocation) 
		
		List copyFiles = [
			"/src/main/java/com/aexp/gcs/poa/transform/feeder/${pFeeder}/${pFeeder}.java",
			"/src/main/java/com/aexp/gcs/poa/transform/lob/${pFeeder}/${pFeeder}.java",
			"/src/main/java/com/aexp/gcs/poa/transform/template/${pTemplate}/${pTemplate}.java",	//	We'll need to edit this one to add business rules 
			"/src/main/java/com/aexp/gcs/poa/validate/feeder/${pFeeder}.java",	// This is the one we need to MERGE if already exists
			"/src/main/java/com/aexp/gcs/poa/validate/lob/${pFeeder}.java",
			"/src/main/java/com/aexp/gcs/poa/validate/template/${pTemplate}.java"			
			]
		
		if (!aPoaFolder.exists()) {
			throw new Exception("POA folder (${appSettings.sourceFolder}/${pFeeder}/POA) for feeder ${pFeeder} does not exist")
		}
		if (!aModuleFolder.exists()) {
			throw new Exception("Business Rules Module for ${pFeeder} (${aModuleFolder.absolutePath}) does not exist")
		}
		if (aTemplateFolder.exists()) {
			println "${pFeeder}'s Template package ${pTemplate} already exists. Will skip this one"
			return
		}
		else {
			aTemplateFolder.mkdirs()
		}
		
		//	Will copy only if files are not already present
		copyFiles.each{ String partialPath ->
			File aModuleFile = new File("${aModuleFolder}${partialPath}")
			File aPoaFile = new File("${aPoaFolder.absolutePath}${partialPath.substring(partialPath.indexOf('/com/'))}")
			
			if (!aModuleFile.exists()) {
				aModuleFile.withWriter { it << aPoaFile.text }
			}
		}
		
		//	Merge validate.feeder.<feeder>.java interfaces
		this.mergeValidateFeederInterfaces(new File("${aModuleFolder}${copyFiles[3]}"), new File("${aPoaFolder.absolutePath}${copyFiles[3].substring(copyFiles[3].indexOf('/com/'))}"))
	}
	
	/**
	 * Given a feeder name and a template this method goes over all variables definitions by loading the corresponding JSON content and evaluating one by one
	 * variables (static and dynamic) and what validations and business rules need to be applied to each one.
	 * @param pFeederName the 3-uppercase character feeder name that corresponds to a folder under sourceFolder
	 * @param pTemplateId  the template name to process. This is the template filename located at sourceFolder/pFeeder/POA/
	 */
	private void processTemplateVariables(String pFeederName, String pTemplateId)
	{
		String	aModuleName 	=	"/business-rules-${pFeederName.toLowerCase()}"
		File	aBusRulesFile	=	new File("${appSettings.outputFolder}/${aModuleName}/src/main/java/com/aexp/gcs/poa/transform/template/${pTemplateId}/${pTemplateId}.java")
		
		BusinessRulesImplementation aBusinessRulesHandler = new BusinessRulesImplementation(aBusRulesFile)
		def 	json			=	this.fixCase(this.checkEnvelopePresence(this.parseJsonFromTemplateFile(pFeederName, pTemplateId)))
				
		if (!json || !json?.variables?.size()) {
			println "Missing JSON section, incorrect format or missing variables element"
			return
		}
		
		json.variables.each{ pVariable ->
			
			//	Process only if there is a mapping and does not contains text in NO_MAPPING_STR
			if (pVariable.mapping && pVariable.mapping.indexOf(NO_MAPPING_STR) == -1) {
				String aFieldName	=	pVariable.mapping.substring(pVariable.mapping.lastIndexOf('.')+1).uncapitalize()
				
				if (this.isDynamicVariable(pVariable.mapping)) {
					//	Process dynamic variable
					String aValidationSourceFile	=	"${appSettings.outputFolder}/${aModuleName}/src/main/java/com/aexp/gcs/poa/validate/feeder/${pFeederName.toUpperCase()}.java"
					DynamicVariableValidation aDynamicVariableHandler = this.getDynamicVariableHandler(aValidationSourceFile)
					pVariable.validations?.each { pValidation ->
						aDynamicVariableHandler.addValidation(aFieldName, pValidation, pTemplateId)
					}
					
				}
				else if (pVariable.className) {
					//	Process static variable
					BeanConstraintsHandler aStaticVariableHandler = this.getStaticVariableHandler(pVariable.className)
					
					pVariable.validations?.each { pValidation ->
						aStaticVariableHandler.addField(pTemplateId, pValidation, aFieldName)
					}
				}
				
				//	Add Business Rules regardless of whether the variable is Static or Dynamic
				aBusinessRulesHandler.addTransformations(pVariable)
			}
		}
		
		aBusinessRulesHandler.persist()
	}
	
	/**
	 * Adds any getters and setters into the Module's validate.feeder.&lt;feeder&gt;.java file that are missing from the corresponding generated file in POA folder 
	 * @param pModuleFile File object pointing to the existing validate.feeder.&lt;feeder&gt;.java interface. Any missing method signatures will be added here
	 * @param pPoaFile File object pointing to the generated validate.feeder.&lt;feeder&gt;.java interface.
	 */
	private void mergeValidateFeederInterfaces(pModuleFile, pPoaFile)
	{
		Map 	aFieldsMap	= [:]
		String	aModuleTxt	= pModuleFile.text
		String	aPoaTxt		= pPoaFile.text
		String	aNewMethods	= ""
		def aPattern		= /(?m)^.*?public\s+(.+?)\sget(.*)\(.*$/
		def aModMatcher		= aModuleTxt =~ aPattern
		def aPoaMatcher		= aPoaTxt =~ aPattern
		
		aModMatcher.each { aFieldsMap[it[2]] = it[1] }
		aPoaMatcher.each { aMatcher ->
			if (!aFieldsMap.containsKey(aMatcher[2])) {
				aNewMethods += buildGetterSetter(aMatcher[2], aMatcher[1])
			}
		}
		
		if (aNewMethods) {
			aModuleTxt = "${aModuleTxt.substring(0, aModuleTxt.lastIndexOf('\n}'))}\n${aNewMethods}}"
			pModuleFile.withWriter{ it << aModuleTxt }
		}
	}

	/**
	 * Build signature getters and setters text
	 * @param pFieldName the name of the field to generate a getter/setter for
	 * @param pFieldType the type of the field.
	 * @return a piece of source code that represents the getter and setter method signatures
	 */
	private String buildGetterSetter(pFieldName, pFieldType)
	{
		String SPACES_BEFORE = '    '
		String SPACES_AFTER = '\n\n'
		
		"${SPACES_BEFORE}public ${pFieldType} get${pFieldName}();${SPACES_AFTER}" +
		"${SPACES_BEFORE}public void set${pFieldName}(${pFieldType} p${pFieldName});${SPACES_AFTER}"
	}

	
	/**
	 * Created a new business-rules-&lt;feeder&gt; with all required folder structure and pom.xml file
	 * @param pFeeder the feeder name
	 */
	private void createBusinessRuleModule(pFeeder)
	{
		String aModuleName = "/business-rules-${pFeeder.toLowerCase()}"
		File aModuleDir = new File("${appSettings.outputFolder}${aModuleName}")
		
		//	if already exists, do nothing
		if (aModuleDir.exists()) return

		String aPomTxt	=	getClass().getResourceAsStream('/filetemplates/business-rules-poa.xml').getText()
		
		new File("${aModuleDir.absolutePath}/src/test/java").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/resources").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/java/com/aexp/gcs/poa/transform/feeder/${pFeeder.toUpperCase()}").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/java/com/aexp/gcs/poa/transform/lob/${pFeeder.toUpperCase()}").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/java/com/aexp/gcs/poa/transform/template").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/java/com/aexp/gcs/poa/validate/feeder").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/java/com/aexp/gcs/poa/validate/lob").mkdirs()
		new File("${aModuleDir.absolutePath}/src/main/java/com/aexp/gcs/poa/validate/template").mkdirs()
		new File("${aModuleDir.absolutePath}/pom.xml").withWriter { it << aPomTxt.replaceAll(/\\\$\{feeder\}\\\$/, pFeeder.toLowerCase())}
	}
	
	/**
	 * Verifies that the translation tool output is complete, no files or directories missing. Raises an exception if something is missing
	 */
	private void validateGeneratedFiles()
	{
		//	TODO: we'll assume the tool output is good :)
	}
	
	/**
	 * Determines whether a mapping string corresponds to a Dynamic variable or not
	 * @param pMapping the mapping string as it came in the output's json section
	 * @return true if corresponds to a Dynamic variable mapping, false otherwise
	 */
	private boolean isDynamicVariable(String pMapping)
	{
		pMapping && 
		(pMapping.indexOf('CommunicationVariables.Variable') > 0 ||
		pMapping.indexOf('CommunicationVariables.VariableGroup') > 0)
	}
	
	
	/**
	 * Fixes the Case on the mapping elements of the json document passed in
	 * @param pJson is the json document containing the mapping elements that need to be checked for propper case
	 * @return pJson with proper case adjusted
	 */
	private fixCase(pJson)
	{
		pJson.variables.each{
			if (it.mapping) {
				it.mapping = it.mapping.split('\\.').collect{ it.capitalize() }.join('.')
			}
		}
		
		pJson
	}
	
	
	/**
	 * Takes a JSON structure as input, finds the "mapping" elements with missing "Envelope" text at the beginning of the value and adds it to the mapping. 
	 * @param pJson the json structure to check for presence of "Envelope" in the mapping tag
	 * @return returns pJson with "Envelope" addes to the mapping that missed it
	 */
	private checkEnvelopePresence(pJson)
	{
		pJson.variables.each{
			if (it.mapping.indexOf('Probably Dynamic') == -1 &&  it.mapping.toLowerCase().indexOf('envelope') != 0)
				it.mapping = "Envelope.${it.mapping}"
		}
		
		pJson
	}
	
	/**
	 * Parses and returns the JSON object that corresponds to a given feeder and template.
	 * @param pFeeder the feeder name, identified by the 3-uppercase character folder name under the output folder root
	 * @param pTemplate the specific template.txt file to load and look for the json section under pFeeder/POA/ folder
	 * @return
	 */
	protected parseJsonFromTemplateFile(String pFeeder, String pTemplate)
	{
		File aTxtFile	=	new File("${this.appSettings.sourceFolder}/${pFeeder}/POA/${pTemplate}.txt")
		def aPattern	=	/(?s).*?Json Output[^\{]*(\{.*})/
		def aMatcher	=	aTxtFile.text =~ aPattern
		
		(aMatcher.size()) ? new JsonSlurper().parseText(aMatcher[0][1]) : null
	}
	
	/**
	 * Keeps a map of Static Variables validation handler where the key is the full class name each one of these handlers manage.
	 * There is only need for one handler per class, so, if the requested handler does not exist yet one gets instantiated. If the
	 * requested handler has already been requested before then no new one is instantiated, instead the existing one is returned 
	 * @param pClassFullName the full class name for which to retrieve a Static Variable handler
	 * @return Static variable bean constraints handler
	 */
	private BeanConstraintsHandler getStaticVariableHandler(String pClassFullName)
	{
		if (!this.beanConstraintsHandlerMap.containsKey(pClassFullName)) {
			String aClassName = pClassFullName.substring(pClassFullName.lastIndexOf('.') + 1)
			this.beanConstraintsHandlerMap[pClassFullName] = new BeanConstraintsHandler(aClassName, this.appSettings, this.messagePlaceholder)
		}
		
		this.beanConstraintsHandlerMap[pClassFullName]
	}
	
	
	/**
	 * Keeps a map of Dynamic Variables validation handlers where the key is the Java source code file path.
	 * There is only need for one handler per class, so, if the requested handler does not exist yet one gets instantiated. If the
	 * requested handler has already been requested before then no new one is instantiated, instead the existing one is returned 
	 * @param pJavaFilename the full path to the java source file to handle
	 * @return Dynamic variables validation handler
	 */
	private DynamicVariableValidation getDynamicVariableHandler(String pJavaFilename)
	{
		pJavaFilename = pJavaFilename.toLowerCase().endsWith('.java') ? pJavaFilename : (pJavaFilename + '.java')
		
		if (!this.dynamicValidationHandlerMap.containsKey(pJavaFilename)) {
			this.dynamicValidationHandlerMap[pJavaFilename] = new DynamicVariableValidation(pJavaFilename)			
		}
		
		this.dynamicValidationHandlerMap[pJavaFilename]
	}
	
	private void closeAllFileHandlers()
	{
		this.beanConstraintsHandlerMap.each { String pClassName, BeanConstraintsHandler pHandler ->
			pHandler.persist()
		}
		
		this.dynamicValidationHandlerMap.each{ pFileName, DynamicVariableValidation pHandler ->
			pHandler.persist()
		}
	}
	
}
